{"version":3,"file":"static/js/324.279c0158.chunk.js","mappings":"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","sources":["../node_modules/events/events.js","../node_modules/@liqvid/recording/dist/esm/RecordingManager.mjs","../node_modules/@liqvid/recording/dist/esm/Control.mjs","../node_modules/@liqvid/utils/dist/esm/time.mjs","../node_modules/@liqvid/recording/dist/esm/recorder.mjs","../node_modules/@liqvid/recording/dist/esm/recorders/marker-recording.mjs","../node_modules/@liqvid/recording/dist/esm/recorders/audio-recording.mjs","../node_modules/@liqvid/recording/dist/esm/recorders/replay-data-recorder.mjs","../node_modules/@liqvid/recording/dist/esm/recorders/video-recording.mjs","../node_modules/@liqvid/utils/dist/esm/misc.mjs","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/@lqv/cursor/dist/esm/recording.mjs"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import { bind } from \"@liqvid/utils/misc\";\nimport { EventEmitter } from \"events\";\n/**\n * Class for managing recording sessions.\n */\nexport class RecordingManager extends EventEmitter {\n    constructor() {\n        super();\n        this.captureData = {};\n        this.setMaxListeners(0);\n        this.paused = false;\n        this.active = false;\n        bind(this, [\"beginRecording\", \"endRecording\", \"pauseRecording\", \"resumeRecording\", \"capture\"]);\n    }\n    /**\n     * Begin recording.\n     *\n     * @emits start\n     */\n    beginRecording(plugins) {\n        this.plugins = plugins;\n        // initialize\n        this.pauseTime = 0;\n        this.intransigentRecorder = void 0;\n        // dependency injection for plugins\n        for (const key in this.plugins) {\n            const recorder = this.plugins[key];\n            recorder.provide({\n                push: (value) => this.capture(key, value),\n                manager: this\n            });\n            this.captureData[key] = [];\n            if (recorder.intransigent) {\n                if (this.intransigentRecorder)\n                    throw new Error(\"At most one intransigent recorder is allowed\");\n                this.intransigentRecorder = recorder;\n            }\n        }\n        // call this as close as possible to beginRecording() to minimize \"lag\"\n        this.baseTime = performance.now();\n        for (const key in this.plugins) {\n            this.plugins[key].beginRecording();\n        }\n        this.paused = false;\n        this.active = true;\n        this.emit(\"start\");\n    }\n    /**\n     * Commit a piece of recording data.\n     * @param key Key for recording source.\n     * @param value Data to record.\n     *\n     * @emits capture\n     */\n    capture(key, value) {\n        this.captureData[key].push(value);\n        this.emit(\"capture\", key, value);\n    }\n    /**\n     * End recording and collect finalized data from recorders.\n     *\n     * @emits finalize\n     */\n    async endRecording() {\n        const endTime = this.getTime();\n        this.duration = endTime;\n        const recording = {};\n        let startDelay = 0, stopDelay = 0;\n        let promise;\n        // stop intransigentRecorder\n        if (this.intransigentRecorder) {\n            promise = this.intransigentRecorder.endRecording();\n        }\n        // stop other recorders\n        for (const key in this.plugins) {\n            if (this.plugins[key] === this.intransigentRecorder)\n                continue;\n            this.plugins[key].endRecording();\n        }\n        // get start/stop delays from intransigentRecorder\n        if (this.intransigentRecorder) {\n            try {\n                const [startTime, stopTime] = await promise;\n                startDelay = startTime;\n                stopDelay = stopTime - endTime;\n                this.duration = this.duration + stopDelay - startDelay;\n            }\n            catch (e) {\n                startDelay = 0;\n                stopDelay = 0;\n                console.error(e);\n            }\n        }\n        // finalize\n        for (const key in this.plugins) {\n            recording[key] = this.plugins[key].finalizeRecording(this.captureData[key], startDelay, stopDelay);\n            this.emit(\"finalize\", key, recording[key]);\n        }\n        this.active = false;\n        this.emit(\"finalize\", undefined, undefined);\n        return recording;\n    }\n    /** Get current recording time. */\n    getTime() {\n        return performance.now() - this.baseTime - this.pauseTime;\n    }\n    /**\n     * Pause recording.\n     *\n     * @emits pause\n     */\n    pauseRecording() {\n        this.lastPauseTime = performance.now();\n        for (const key in this.plugins) {\n            this.plugins[key].pauseRecording();\n        }\n        this.paused = true;\n        this.emit(\"pause\");\n    }\n    /**\n     * Resume recording from paused state.\n     *\n     * @emits resume\n     */\n    resumeRecording() {\n        this.pauseTime += performance.now() - this.lastPauseTime;\n        for (const key in this.plugins) {\n            this.plugins[key].resumeRecording();\n        }\n        this.paused = false;\n        this.emit(\"resume\");\n    }\n}\n","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useRef, useState } from \"react\";\nimport { Keymap } from \"@liqvid/keymap\";\nimport { useKeymap } from \"@liqvid/keymap/react\";\nimport { onClick, useForceUpdate } from \"@liqvid/utils/react\";\nimport { RecordingManager } from \"./RecordingManager.mjs\";\nimport RecordingRow from \"./RecordingRow.mjs\";\nconst mac = navigator.platform === \"MacIntel\";\nconst bindings = {\n    start: mac ? \"Alt+Meta+2\" : \"Ctrl+Alt+2\",\n    pause: mac ? \"Alt+Meta+3\" : \"Ctrl+Alt+3\",\n    discard: mac ? \"Alt+Meta+4\" : \"Ctrl+Alt+4\"\n};\n/**\n * Liqvid recording control.\n */\nexport function RecordingControl(props) {\n    const keymap = useKeymap();\n    const [recordings, setRecordings] = useState([]);\n    const forceUpdate = useForceUpdate();\n    // recording manager\n    const manager = useRef();\n    useEffect(() => {\n        manager.current = props.manager ?? new RecordingManager();\n        manager.current.on(\"finalize\", forceUpdate);\n        manager.current.on(\"start\", forceUpdate);\n        manager.current.on(\"pause\", forceUpdate);\n        manager.current.on(\"resume\", forceUpdate);\n    }, []);\n    // active plugins\n    const activePlugins = useRef(null);\n    if (activePlugins.current === null) {\n        activePlugins.current = {};\n        for (const plugin of props.plugins) {\n            activePlugins.current[plugin.key] = false;\n        }\n    }\n    // plugins dictionary\n    const [pluginsByKey] = useState(() => {\n        const dict = {};\n        for (const plugin of props.plugins) {\n            dict[plugin.key] = plugin;\n        }\n        return dict;\n    });\n    /* commands */\n    const start = useCallback(() => {\n        const { active, beginRecording, endRecording } = manager.current;\n        if (active) {\n            endRecording().then((recording) => {\n                recording.duration = manager.current.duration;\n                setRecordings(prev => prev.concat(recording));\n            });\n        }\n        else {\n            const recorders = {};\n            for (const plugin of props.plugins) {\n                if (activePlugins.current[plugin.key]) {\n                    recorders[plugin.key] = plugin.recorder;\n                }\n            }\n            beginRecording(recorders);\n        }\n    }, []);\n    const pause = useCallback(() => {\n        const { active, paused, pauseRecording, resumeRecording } = manager.current;\n        if (active) {\n            paused ? resumeRecording() : pauseRecording();\n        }\n    }, []);\n    const discard = useCallback(async () => {\n        const { active, endRecording } = manager.current;\n        if (active) {\n            const listeners = manager.current.listeners(\"finalize\");\n            for (const listener of listeners) {\n                manager.current.off(\"finalize\", listener);\n            }\n            try {\n                await endRecording();\n            }\n            catch (e) {\n                console.error(e);\n            }\n            for (const listener of listeners) {\n                manager.current.on(\"finalize\", listener);\n            }\n            forceUpdate();\n        }\n    }, []);\n    /* keyboard controls */\n    const callbacks = useMemo(() => ({ start, pause, discard }), []);\n    const reducer = useCallback((state, action) => {\n        // rebind\n        keymap.unbind(state[action.command], callbacks[action.command]);\n        keymap.bind(action.seq, callbacks[action.command]);\n        // return new state\n        return {\n            ...state,\n            [action.command]: action.seq\n        };\n    }, []);\n    const [state, dispatch] = useReducer(reducer, bindings);\n    // initial bind\n    useEffect(() => {\n        for (const key in state) {\n            keymap.bind(state[key], callbacks[key]);\n        }\n    }, []);\n    // onBlur event, triggers rebind\n    const onBlur = useCallback((e) => {\n        e.preventDefault();\n        const name = e.currentTarget.getAttribute(\"name\");\n        // bind sequence\n        const seq = e.currentTarget.dataset.value;\n        dispatch({ command: name, seq });\n    }, []);\n    // display shortcut sequence\n    const identifyKey = useCallback((e) => {\n        e.preventDefault();\n        const seq = Keymap.identify(e);\n        e.currentTarget.dataset.value = seq;\n        e.currentTarget.value = fmtSeq(seq);\n    }, []);\n    // warn before closing if recordings exist\n    const warn = useRef(false);\n    warn.current = recordings.length > 0;\n    useEffect(() => {\n        window.addEventListener(\"beforeunload\", (e) => {\n            if (warn.current)\n                e.returnValue = \"You have recording data\";\n        });\n    }, []);\n    // show/hide control pane\n    const [paneOpen, setPaneOpen] = useState(false);\n    const togglePane = useMemo(() => onClick(() => {\n        setPaneOpen(prev => !prev);\n    }), []);\n    const dialogStyle = {\n        display: paneOpen ? \"block\" : \"none\"\n    };\n    // toggle plugin\n    const setActive = useMemo(() => onClick((e) => {\n        const key = e.currentTarget.dataset.plugin;\n        activePlugins.current[key] = !activePlugins.current[key];\n        forceUpdate();\n    }), []);\n    /* render */\n    const commands = [\n        [\"Start/Stop recording\", \"start\"],\n        [\"Pause recording\", \"pause\"],\n        [\"Discard recording\", \"discard\"]\n    ];\n    return (_jsxs(\"div\", { id: \"lv-recording\", children: [_jsxs(\"div\", { id: \"lv-recording-dialog\", style: dialogStyle, children: [_jsx(\"table\", { id: \"lv-recording-configuration\", children: _jsxs(\"tbody\", { children: [_jsx(\"tr\", { children: _jsx(\"th\", { colSpan: 2, children: \"Commands\" }) }), commands.map(([desc, key]) => (_jsxs(\"tr\", { children: [_jsx(\"th\", { scope: \"row\", children: desc }), _jsx(\"td\", { children: _jsx(\"input\", { onBlur: onBlur, readOnly: true, onKeyDown: identifyKey, className: \"shortcut\", name: key, type: \"text\", value: fmtSeq(state[key]) }) })] }, key)))] }) }), _jsx(\"h3\", { children: \"Configuration\" }), props.plugins.map((plugin) => {\n                        const classNames = [\"recorder-plugin-icon\"];\n                        if (activePlugins.current[plugin.key])\n                            classNames.push(\"active\");\n                        const styles = {};\n                        const enabled = typeof plugin.enabled === \"undefined\" || plugin.enabled();\n                        if (!enabled) {\n                            styles.opacity = 0.3;\n                        }\n                        return (_jsxs(\"div\", { className: \"recorder-plugin\", title: plugin.title, style: styles, children: [_jsxs(\"svg\", { className: classNames.join(\" \"), height: \"36\", width: \"36\", viewBox: \"0 0 100 100\", \"data-plugin\": plugin.key, ...(enabled ? setActive : {}), children: [_jsx(\"rect\", { height: \"100\", width: \"100\", fill: activePlugins.current[plugin.key] ? \"red\" : \"#222\" }), plugin.icon] }), _jsx(\"span\", { className: \"recorder-plugin-name\", children: plugin.name })] }, plugin.key));\n                    }), _jsx(\"h3\", { children: \"Saved data\" }), _jsx(\"ol\", { className: \"recordings\", children: recordings.map((recording, i) => (_jsx(RecordingRow, { data: recording, pluginsByKey: pluginsByKey }, i))) })] }), _jsx(\"svg\", { height: \"36\", width: \"36\", viewBox: \"-50 -50 100 100\", ...togglePane, children: _jsx(\"circle\", { cx: \"0\", cy: \"0\", r: \"35\", stroke: \"white\", strokeWidth: \"5\", fill: manager.current?.active ? (manager.current?.paused ? \"yellow\" : \"red\") : \"#666\" }) })] }));\n}\n/** Format key sequences with special characters on Mac */\nfunction fmtSeq(str) {\n    if (navigator.platform !== \"MacIntel\")\n        return str;\n    if (str === void 0)\n        return str;\n    return str.split(\"+\").map(k => {\n        if (k === \"Ctrl\")\n            return \"^\";\n        else if (k === \"Alt\")\n            return \"⌥\";\n        if (k === \"Shift\")\n            return \"⇧\";\n        if (k === \"Meta\")\n            return \"⌘\";\n        return k;\n    }).join(\"\");\n}\n","/* time constants */\nconst SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\nconst HOURS = 60 * MINUTES;\nconst DAYS = 24 * HOURS;\n// nice minus sign\nconst MINUS_SIGN = \"\\u2212\";\n/**\n * Regular expression used to match times\n */\nexport const timeRegexp = new RegExp(\"^\" + \"(?:(\\\\d+):)?\".repeat(3) + \"(\\\\d+)(?:\\\\.(\\\\d+))?$\");\n/**\n * Parse a time string like \"3:43\" into milliseconds\n * @param str String to parse\n * @returns Time in milliseconds\n */\nexport function parseTime(str) {\n    if (str[0] === MINUS_SIGN || str[0] === \"-\") {\n        return -parseTime(str.slice(1));\n    }\n    // d, h, m, s\n    const parts = str.split(\":\").map((x) => parseInt(x, 10));\n    while (parts.length < 4) {\n        parts.unshift(0);\n    }\n    // ms\n    const $_ = str.match(/\\.(\\d{0,3})/);\n    if ($_) {\n        parts.push(parseInt($_[1].padEnd(3, \"0\")));\n    }\n    else {\n        parts.push(0);\n    }\n    const [days, hours, minutes, seconds, milliseconds] = parts;\n    return (milliseconds + 1000 * (seconds + 60 * (minutes + 60 * (hours + 24 * days))));\n}\n/**\n * Format a duration as a {@link https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-duration-string time duration string}\n * for use as a {@link https://html.spec.whatwg.org/multipage/text-level-semantics.html#attr-time-datetime datetime} attribute.\n * @param time Duration in milliseconds.\n * @returns A duration string such as \"PT4H18M3S\".\n * @since 1.7.0\n */\nexport function formatTimeDuration(time) {\n    const parts = [\"P\"];\n    const timeParts = [];\n    const days = Math.floor(time / DAYS), hours = Math.floor((time / HOURS) % 24), minutes = Math.floor((time / MINUTES) % 60), seconds = (time / SECONDS) % 60;\n    if (days > 0) {\n        parts.push(`${days}D`);\n    }\n    if (hours > 0) {\n        timeParts.push(`${hours}H`);\n    }\n    if (minutes > 0) {\n        timeParts.push(`${minutes}M`);\n    }\n    if (seconds > 0) {\n        timeParts.push(`${seconds.toFixed(3).replace(/\\.?0+$/, \"\")}S`);\n    }\n    if (timeParts.length > 0) {\n        parts.push(\"T\", ...timeParts);\n    }\n    return parts.join(\"\");\n}\n/**\n * Format a time as \"mm:ss\"\n * @param time Time in milliseconds\n * @returns Formatted time\n */\nexport function formatTime(time) {\n    if (time < 0) {\n        return MINUS_SIGN + formatTime(-time);\n    }\n    const days = Math.floor(time / DAYS), hours = Math.floor((time / HOURS) % 24), minutes = Math.floor((time / MINUTES) % 60), seconds = Math.floor((time / SECONDS) % 60);\n    let firstNonzero = true;\n    let str = \"\";\n    for (const part of [days, hours, minutes]) {\n        if (firstNonzero) {\n            if (part !== 0) {\n                firstNonzero = false;\n                str += part.toString() + \":\";\n            }\n        }\n        else {\n            str += part.toString().padStart(2, \"0\") + \":\";\n        }\n    }\n    // display 0:ss\n    if (firstNonzero) {\n        str += \"0:\";\n    }\n    str += seconds.toString().padStart(2, \"0\");\n    return str;\n}\n/**\n * Format a time as \"mm:ss.ms\"\n * @param time Time in milliseconds\n * @returns Formatted time\n */\nexport function formatTimeMs(time) {\n    if (time < 0) {\n        return MINUS_SIGN + formatTimeMs(-time);\n    }\n    const milliseconds = Math.floor(time % 1000);\n    if (milliseconds === 0) {\n        return formatTime(time);\n    }\n    return (formatTime(time) +\n        \".\" +\n        String(milliseconds).padStart(3, \"0\").replace(/0+$/, \"\"));\n}\n","/**\n * Abstract class for recording interactions.\n */\nexport class Recorder {\n    constructor() {\n        /**\n        A recorder is intransigent if it cannot be started immediately (e.g. AudioRecorder).\n        */\n        this.intransigent = false;\n    }\n    /** Begin recording. */\n    beginRecording() { }\n    /** Pause recording. */\n    pauseRecording() { }\n    /** Resume recording from paused. */\n    resumeRecording() { }\n    /** End recording. */\n    endRecording() { }\n    finalizeRecording(data, startDelay = 0, stopDelay = 0) {\n        return data;\n    }\n    provide({ push, manager }) {\n        this.push = push;\n        this.manager = manager;\n    }\n    getUpdate(data, lastDuration) { }\n}\n","import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { bind } from \"@liqvid/utils/misc\";\nimport { formatTimeMs } from \"@liqvid/utils/time\";\nimport { Recorder } from \"../recorder.mjs\";\nconst icon = (_jsx(\"text\", { fill: \"#FFF\", fontFamily: \"Helvetica\", fontSize: \"75\", textAnchor: \"middle\", x: \"50\", y: \"75\", children: \"M\" }));\nexport class MarkerRecorder extends Recorder {\n    constructor() {\n        super();\n        bind(this, [\"onMarkerUpdate\"]);\n    }\n    beginRecording() {\n        this.lastTime = 0;\n        this.script.on(\"markerupdate\", this.onMarkerUpdate);\n    }\n    endRecording() {\n        this.script.off(\"markerupdate\", this.onMarkerUpdate);\n        this.captureMarker(this.script.markerName);\n    }\n    finalizeRecording(data, startDelay, stopDelay) {\n        data[0][1] -= startDelay;\n        data[data.length - 1][1] += stopDelay;\n        return data.map(cue => [cue[0], formatTimeMs(cue[1])]);\n    }\n    onMarkerUpdate(prevIndex) {\n        if (this.manager.paused)\n            return;\n        this.captureMarker(this.script.markers[prevIndex][0]);\n    }\n    captureMarker(markerName) {\n        const t = this.manager.getTime();\n        this.push([markerName, t - this.lastTime]);\n        this.lastTime = t;\n    }\n}\nexport function MarkerSaveComponent(props) {\n    return (_jsx(_Fragment, { children: _jsx(\"textarea\", { readOnly: true, value: format(props.data) }) }));\n}\nexport const MarkerRecording = {\n    icon,\n    key: \"markers\",\n    name: \"Markers\",\n    recorder: new MarkerRecorder,\n    saveComponent: MarkerSaveComponent\n};\nfunction format(data) {\n    return JSON.stringify(data, null, 2).replace(/\\[\\s+\"(.+?)\",\\s+\"(.+?)\"\\s+\\]/g, \"[\\\"$1\\\", \\\"$2\\\"]\");\n}\n","import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { Recorder } from \"../recorder.mjs\";\nconst icon = (_jsx(\"g\", { transform: \"scale(0.126261032057) translate(164.575)\", children: _jsxs(\"g\", { stroke: \"#FFF\", transform: \"translate(-140.62 -173.21)\", children: [_jsx(\"path\", { d: \"m568.57 620.93c0 116.77-94.66 211.43-211.43 211.43s-211.43-94.66-211.43-211.43v-0.00001\", fillOpacity: \"0\", transform: \"translate(14.904)\", strokeLinecap: \"round\", strokeWidth: \"20\" }), _jsx(\"path\", { d: \"m568.57 620.93c0 116.77-94.66 211.43-211.43 211.43s-211.43-94.66-211.43-211.43v-0.00001\", fillOpacity: \"0\", transform: \"translate(14.904)\", strokeLinecap: \"round\", strokeWidth: \"40\" }), _jsx(\"path\", { d: \"m372.05 832.36v114.29\", strokeWidth: \"30\", fill: \"none\" }), _jsx(\"path\", { fill: \"#FFF\", d: \"m197.14 920.93c0.00001-18.935 59.482-34.286 132.86-34.286 73.375 0 132.86 15.35 132.86 34.286z\", transform: \"translate(42.047 34.286)\", strokeLinecap: \"round\", strokeWidth: \"20\" }), _jsx(\"path\", { fill: \"#FFF\", strokeWidth: \"21.455\", strokeLinecap: \"round\", d: \"m372.06 183.94c-77.019-0.00001-139.47 62.45-139.47 139.47v289.62c0 77.019 62.45 139.47 139.47 139.47 77.019 0 139.44-62.45 139.44-139.47v-289.62c0-77.02-62.42-139.47-139.44-139.47z\" })] }) }));\nexport class AudioRecorder extends Recorder {\n    constructor() {\n        super(...arguments);\n        this.requested = false;\n        this.intransigent = true;\n    }\n    beginRecording() {\n        if (!this.stream)\n            throw new Error(\"Navigator stream not available\");\n        this.promise = new Promise(async (resolve, reject) => {\n            // record the audio\n            this.mediaRecorder = new MediaRecorder(this.stream, { mimeType: \"audio/webm\" });\n            // subscribe to events\n            this.mediaRecorder.addEventListener(\"dataavailable\", e => {\n                this.push(e.data);\n            });\n            let startDelay;\n            this.mediaRecorder.addEventListener(\"start\", () => {\n                startDelay = this.manager.getTime();\n            });\n            this.mediaRecorder.addEventListener(\"stop\", () => {\n                resolve([startDelay, this.manager.getTime()]);\n            });\n            this.mediaRecorder.start();\n        });\n    }\n    pauseRecording() {\n        this.mediaRecorder.pause();\n    }\n    resumeRecording() {\n        this.mediaRecorder.resume();\n    }\n    async endRecording() {\n        this.mediaRecorder.stop();\n        return this.promise;\n    }\n    finalizeRecording(chunks) {\n        return new Blob(chunks, { type: \"audio/webm\" });\n    }\n    requestRecording() {\n        // be idempotent\n        if (this.requested)\n            return;\n        const request = async () => {\n            // Only need to do this once...\n            window.removeEventListener(\"click\", request);\n            try {\n                this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n            }\n            catch (e) {\n                // User said no or browser rejected request due to insecure context\n                console.log(\"no recording allowed\");\n            }\n        };\n        // Need user interaction to request media\n        window.addEventListener(\"click\", request);\n        this.requested = true;\n    }\n}\nexport function AudioSaveComponent(props) {\n    return (_jsx(_Fragment, { children: props.data ?\n            _jsx(\"a\", { download: \"audio.webm\", href: URL.createObjectURL(props.data), children: \"Download Audio\" })\n            :\n                \"Audio not yet available\" }));\n}\nconst recorder = new AudioRecorder();\nexport const AudioRecording = {\n    enabled: () => {\n        if (typeof recorder.stream === \"undefined\") {\n            recorder.requestRecording();\n            return false;\n        }\n        return true;\n    },\n    icon,\n    key: \"audio\",\n    name: \"Audio\",\n    recorder,\n    saveComponent: AudioSaveComponent,\n    title: \"Record audio\"\n};\n","import { Recorder } from \"../recorder.mjs\";\nexport class ReplayDataRecorder extends Recorder {\n    constructor() {\n        super();\n        this.duration = 0;\n    }\n    beginRecording() {\n        this.duration = 0;\n    }\n    finalizeRecording(data, startDelay = 0, stopDelay = 0) {\n        // for (let sum = 0, i = 0; i < data.length && sum < startDelay; ++i) {\n        //   const dur = data[i][0];\n        //   if (dur === 0) {\n        //     continue;\n        //   }\n        //   if (sum + dur >= startDelay) {\n        //     data[i][0] -= startDelay - sum;\n        //     break;\n        //   }\n        //   sum += dur;\n        //   // data.splice(i, 1);\n        //   --i;\n        // }\n        // console.log(JSON.stringify(data, null, 2));\n        return compress(data);\n    }\n    capture(time = this.manager.getTime(), data) {\n        if (time - this.duration < 0) {\n            // console.error(time, this.duration, data);\n        }\n        this.push([time - this.duration, data]);\n        this.duration = time;\n    }\n}\n/**\n * Truncate numerical precision to reduce filesize.\n * @param o Data to compress.\n * @param precision Number of decimal points to include.\n */\nexport function compress(o, precision = 2) {\n    switch (typeof o) {\n        case \"object\":\n            if (o instanceof Array) {\n                return o.map(val => compress(val, precision));\n            }\n            return Object.fromEntries(Object.keys(o).map(key => [key, compress(o[key], precision)]));\n        case \"number\":\n            return parseFloat(o.toFixed(precision));\n        default:\n            return o;\n    }\n}\n","import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { Recorder } from \"../recorder.mjs\";\nconst icon = (_jsx(\"path\", { fill: \"#FFF\", d: \"M35.113 14.703a4.558 4.558 0 0 0-4.568 4.568v2.338h-11.29A13.146 13.146 0 0 0 6.082 34.787v37.018a13.142 13.142 0 0 0 13.173 13.172H80.74a13.147 13.147 0 0 0 13.178-13.172V34.787A13.146 13.146 0 0 0 80.74 21.61H69.455v-2.338a4.558 4.558 0 0 0-4.568-4.568H35.113ZM50 31.196c12.18 0 22.103 9.917 22.103 22.097 0 12.18-9.923 22.103-22.103 22.103-12.181 0-22.103-9.923-22.103-22.103 0-12.18 9.922-22.097 22.103-22.097Zm-30.073.835a4.59 4.59 0 0 1 4.59 4.59h.006a4.59 4.59 0 1 1-4.595-4.59ZM50 35.536a17.721 17.721 0 0 0-17.757 17.757A17.722 17.722 0 0 0 50 71.05a17.723 17.723 0 0 0 17.757-17.757A17.722 17.722 0 0 0 50 35.536Z\" }));\nexport class VideoRecorder extends Recorder {\n    constructor() {\n        super(...arguments);\n        this.requested = false;\n        this.intransigent = true;\n    }\n    beginRecording() {\n        if (!this.stream)\n            throw new Error(\"Navigator stream not available\");\n        this.promise = new Promise(async (resolve) => {\n            // record the video\n            this.mediaRecorder = new MediaRecorder(this.stream, { mimeType: \"video/webm\" });\n            // subscribe to events\n            this.mediaRecorder.addEventListener(\"dataavailable\", e => {\n                this.push(e.data);\n            });\n            let startDelay;\n            this.mediaRecorder.addEventListener(\"start\", () => {\n                startDelay = this.manager.getTime();\n            });\n            this.mediaRecorder.addEventListener(\"stop\", () => {\n                resolve([startDelay, this.manager.getTime()]);\n            });\n            this.mediaRecorder.start();\n        });\n    }\n    pauseRecording() {\n        this.mediaRecorder.pause();\n    }\n    resumeRecording() {\n        this.mediaRecorder.resume();\n    }\n    async endRecording() {\n        this.mediaRecorder.stop();\n        return this.promise;\n    }\n    finalizeRecording(chunks) {\n        return new Blob(chunks, { type: \"video/webm\" });\n    }\n    requestRecording() {\n        // be idempotent\n        if (this.requested)\n            return;\n        const request = async () => {\n            // Only need to do this once...\n            window.removeEventListener(\"click\", request);\n            try {\n                this.stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });\n            }\n            catch (e) {\n                // User said no or browser rejected request due to insecure context\n                console.log(\"no recording allowed\");\n            }\n        };\n        // Need user interaction to request media\n        window.addEventListener(\"click\", request);\n    }\n}\nexport function VideoSaveComponent(props) {\n    return (_jsx(_Fragment, { children: props.data ?\n            _jsx(\"a\", { download: \"video.webm\", href: URL.createObjectURL(props.data), children: \"Download Video\" })\n            :\n                \"Video not yet available\" }));\n}\nconst recorder = new VideoRecorder();\nexport const VideoRecording = {\n    enabled: () => {\n        if (typeof recorder.stream === \"undefined\") {\n            recorder.requestRecording();\n            return false;\n        }\n        return true;\n    },\n    icon,\n    key: \"video\",\n    name: \"Video\",\n    recorder,\n    saveComponent: VideoSaveComponent,\n    title: \"Record video\"\n};\n","/** Equivalent to `(min <= val) && (val < max)`. */\nexport function between(min, val, max) {\n    return min <= val && val < max;\n}\n/**\n * Bind methods on an object.\n * @param o Object on which to bind methods\n * @param methods Method names to bind\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function bind(o, methods) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    for (const method of methods)\n        o[method] = o[method].bind(o);\n}\n/**\n * Linear interpolation from a to b.\n */\nexport function lerp(a, b, t) {\n    return a + t * (b - a);\n}\n/**\n * Clamps a value between a lower and upper bound. Aliased as {@link constrain}.\n * @param min Lower bound\n * @param val Value to clamp\n * @param max Upper bound\n */\nexport function clamp(min, val, max) {\n    return Math.min(max, Math.max(min, val));\n}\n/**\n * Clamps a value between a lower and upper bound. Alias for {@link clamp}.\n * @param min Lower bound\n * @param val Value to clamp\n * @param max Upper bound\n */\nexport function constrain(min, val, max) {\n    return clamp(min, val, max);\n}\n/**\n  Returns [a, b). For backwards compatibility, returns [0, a) if passed a single argument.\n*/\nexport function range(a, b) {\n    if (b === void 0) {\n        return range(0, a);\n    }\n    return new Array(b - a).fill(null).map((_, i) => a + i);\n}\n/** Returns a Promise that resolves in `time` milliseconds. */\nexport function wait(time) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, time);\n    });\n}\n/** Returns a Promise that resolves once `callback` returns true. */\nexport function waitFor(callback, interval = 10) {\n    return new Promise((resolve) => {\n        const checkCondition = () => {\n            if (callback()) {\n                resolve();\n            }\n            else {\n                setTimeout(checkCondition, interval);\n            }\n        };\n        checkCondition();\n    });\n}\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}","import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { compress, ReplayDataRecorder } from \"@liqvid/recording\";\nimport { bind } from \"@liqvid/utils/misc\";\nexport class CursorRecorder extends ReplayDataRecorder {\n    /** Container element for recording. */\n    target = document.body;\n    constructor() {\n        super();\n        bind(this, [\"captureMouse\"]);\n    }\n    beginRecording() {\n        // DO NOT FORGET TO CALL super\n        super.beginRecording();\n        document.body.addEventListener(\"mousemove\", this.captureMouse);\n    }\n    endRecording() {\n        document.body.removeEventListener(\"mousemove\", this.captureMouse);\n    }\n    captureMouse(e) {\n        const t = this.manager.getTime();\n        if (this.manager.paused)\n            return;\n        const { left, top, height, width } = this.target.getBoundingClientRect();\n        this.capture(t, [((e.pageX - left) / width) * 100, ((e.pageY - top) / height) * 100]);\n    }\n    finalizeRecording(data) {\n        return compress(data, 4);\n    }\n}\nconst CursorSaveComponent = (props) => {\n    return (_jsx(_Fragment, { children: props.data ? (_jsx(\"textarea\", { readOnly: true, value: JSON.stringify(props.data) })) : (\"Cursor data not yet available.\") }));\n};\nconst icon = (_jsxs(\"g\", { children: [_jsx(\"line\", { x1: \"0\", x2: \"100\", y1: \"50\", y2: \"50\", stroke: \"#FFF\" }), _jsx(\"line\", { x1: \"50\", x2: \"50\", y1: \"0\", y2: \"100\", stroke: \"#FFF\" })] }));\nexport const CursorRecording = {\n    icon,\n    key: \"cursor\",\n    name: \"Cursor\",\n    recorder: new CursorRecorder(),\n    saveComponent: CursorSaveComponent,\n    title: \"Record cursor\",\n};\n"],"names":["ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","module","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","RecordingManager","captureData","paused","active","plugins","pauseTime","intransigentRecorder","recorder","provide","capture","manager","intransigent","baseTime","performance","now","beginRecording","endTime","getTime","duration","recording","startDelay","stopDelay","promise","endRecording","startTime","stopTime","finalizeRecording","lastPauseTime","pauseRecording","resumeRecording","navigator","platform","SECONDS","MINUTES","HOURS","DAYS","RegExp","repeat","formatTime","time","days","Math","floor","hours","minutes","seconds","firstNonzero","str","part","toString","padStart","formatTimeMs","milliseconds","replace","Recorder","data","lastDuration","_jsx","fill","fontFamily","fontSize","textAnchor","x","y","children","lastTime","script","onMarkerUpdate","captureMarker","markerName","map","cue","prevIndex","markers","t","transform","_jsxs","stroke","d","fillOpacity","strokeLinecap","strokeWidth","AudioRecorder","requested","stream","mediaRecorder","MediaRecorder","mimeType","e","start","pause","resume","stop","chunks","Blob","request","window","mediaDevices","getUserMedia","audio","log","ReplayDataRecorder","compress","o","precision","val","fromEntries","parseFloat","toFixed","VideoRecorder","video","methods","method","_superPropBase","object","property","hasOwnProperty","_get","base","desc","getOwnPropertyDescriptor","CursorRecorder","document","body","captureMouse","getBoundingClientRect","left","top","height","width","pageX","pageY","x1","x2","y1","y2"],"sourceRoot":""}