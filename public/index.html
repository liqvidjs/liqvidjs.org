<h2>Getting Started</h2>

TODO: link minimal working example/tutorial

<h2>Phases of development</h2>

<p>In my experience, the process of creating a ractive can be divided into three phases. (This does not include the creative phase of deciding <em>what</em> you want to say, which is usually the hardest part.)</p>

<ol>
  <li><a href="/authoring.html">Authoring</a>: This is when you write HTML/CSS/Javascript for your ractive.</li>

  <li><a href="/recording.html">Recording</a>: This is when you record audio and other interactions.</li>

  <li><a href="/mastering.html">Mastering</a>: This is for the finishing touches on a video, ensuring cross-platform compatibility, etc.</li>
</ol>

<p>The above links provide practical advice on the issues that arise in each phase.</p>

<h2>Classes and Concepts</h2>

<h3>Playback</h3>

<p>This is the most important class. Effectively, this mimics an audio/video element that can be played and rewinded, has volume controls, a playback rate, etc. It thus imitates the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/">HTMLMediaElement</a> interface to a certain extent, although it does not fully implement that interface.</p>

<p>Times are generally represented as numbers representing milliseconds since the beginning of playback. They can also be specified as strings like <code>"7:35"</code> or <code>"7:35.66"</code>. Currently, there is no distinction between time points and time durations.</p>

<p><strong>Warning: the HTMLMediaElement interface usually represents times in <em>seconds</em>.</strong></p>

<h3>Script</h3>

<p>A <code>Script</code> augments a <code>Playback</code> by distinguishing specific timepoints, which we call <dfn>markers</dfn> (<em>cue</em> would also be appropriate, but that conflicts with WebVTT Cues).</p>

<h4>Markers</h4>

<p>A <dfn>marker</dfn> is a triple <code class="language-typescript">[name: string, start: number, end: number]</code>, where <code>start</code> and <code>end</code> are times in the sense of the previous section. However, when creating a <code>Script</code> a marker may be specified as a pair <code class="language-typescript">[name: string, duration: number]</code>.</p>

<h3>Player</h3>

A <code>Player</code> provides a GUI interface for playing ractives, resembling a traditional web video player.

<h4>Showing/Hiding</h4>

<p>If an element has the <code class="language-html">data-from-first="first"</code> attribute, it will be visible only when the current marker is equal to or comes after the marker whose name is <code>"first"</code>. If an element further has the <code class="language-html">data-from-last="last"</code> attribute, it will be visible only when the current marker comes strictly before the marker whose name is <code>"last"</code>. If an element has the <code class="language-html">data-during="prefix"</code> attribute, it will be visible only when the current marker's name begins with <code>"prefix"</code>. There are helper functions for this in <a class="todo">Utils.authoring</a>.</p>

<p>Internally, elements are hidden by setting <code class="language-css">opacity:0; pointer-events: none;</code>, and shown by removing these attributes. The reason for using these styles instead of <code class="language-css">visibility: hidden;</code> is that an invisible element can have visible children with the latter approach, whereas our approach allows us to hide an element without recursing into its children. This operates outside of React rendering.</p>

<p class="todo">insert warning about starting</p>

<p>It may seem strange to render everything at the beginning and then selectively show/hide it, rather than rendering selectively based on the current time. My own use case for this library uses a lot of MathJax, which takes a few seconds to render, so selective rendering would disrupt the viewing experience. If you don't have any content with long repaints, selective rendering will probably work fine.</p>

<p class="todo">explain case for selective rendering (whitespace)</p>

<h4>Styling</h4>

<p>This can be styled to a certain extent with the following CSS variables:</p>

<pre><code class="language-css">
/* default values */
.ractive-player {
  --rp-controls-height: 44px;
  --rp-elapsed-color: #AF1866;
  --rp-scrubber-color: #AF1866;
  --rp-scrub-height: 6px;
}

/* these ones control the aspect ratio --- default is 8/5 */
@media (min-aspect-ratio: 8/5) {
  :root {
    font-size: 2vh;
  }

  .ractive-player {
    --rp-height: 100vh;
    --rp-width: 160vh;
  }

  .rp-canvas {
    margin: 0 auto;
  }
}

@media (max-aspect-ratio: 8/5) {
  :root {
    font-size: 1.25vw;
  }

  .ractive-player {
    --rp-height: 62.5vw;
    --rp-width: 100vw;
  }
  .rp-canvas {
    top: calc((100% - 62.5vw) / 2);
  }
}
</code></pre>

It is important that <code>Playback</code> and <code>Script</code> do not depend on React, and could be used without <code>Player</code> (for example, you could use this library to make an interactive audio player). Eventually we will be more agnostic about templating systems, so that e.g. Vue or Custom Elements could be used instead of (or in conjunction with) React.

<h3>ReplayData</h3>

This is a common pattern in RP elements replaying something recorded by the author (cursor movements, typing, etc.). It is not part of the JavaScript code, but is exported from the TypeScript.

<pre><code class="language-typescript">
type ReplayData&lt;K&gt; = [number, K][];
</code></pre>

The numbers represent durations in milliseconds. Thus, a piece of <code>ReplayData</code> is usually paired with a <code>start</code> attribute for replaying, but <code>ReplayData</code> itself does not involve absolute times, so it can be moved around easily.

<!--
## History

Knowing the history of this project may help to understand some of the design decisions. The idea of a medium synthesizing---and dissolving the difference between--video and interactive text, as well as the word *ractive*, came from reading Neal Stephenson's [The Diamond Age](https://en.wikipedia.org/wiki/The_Diamond_Age) in 2012/2013. (Though the ractives in The Diamond Age are much more powerful than this module is.)

At the time, I tried to build something like this using a lot of XML and XSLT, and later Custom Elements (React didn't exist yet, plus I used to really Believe in XML). The basic model was to record an ordinary video, then add Javascript events to fire at specific timepoints and control the video.
-->